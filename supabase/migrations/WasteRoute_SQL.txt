-- Start fresh
DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;

-- Initial setup
ALTER DATABASE postgres SET timezone TO 'UTC';
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Grant initial permissions
GRANT ALL ON SCHEMA public TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres, anon, authenticated, service_role;

-- Grant auth schema permissions to service role
GRANT USAGE ON SCHEMA auth TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;

-- Create ENUMs
CREATE TYPE public.route_status AS ENUM ('pending', 'in_progress', 'completed', 'expired');
CREATE TYPE public.house_status AS ENUM ('pending', 'collect', 'skip', 'new customer');
CREATE TYPE public.user_role AS ENUM ('driver', 'admin');
CREATE TYPE public.user_status AS ENUM ('active', 'inactive');

-- Create teams table before profiles
DROP TABLE IF EXISTS public.teams CASCADE;
CREATE TABLE public.teams (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    name text NOT NULL,
    owner_id uuid REFERENCES auth.users ON DELETE SET NULL
);
ALTER TABLE public.teams ENABLE ROW LEVEL SECURITY;

-- Create basic team owner policy (will add member policy after profiles exists)
CREATE POLICY "Team owners can manage their teams" ON teams
    FOR ALL USING (owner_id = auth.uid());

-- PROFILES TABLE
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
    id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    full_name text NOT NULL,
    email text NOT NULL UNIQUE,
    role user_role NOT NULL DEFAULT 'driver',
    status user_status NOT NULL DEFAULT 'active',
    phone text,
    preferred_region text,
    start_date date DEFAULT now(),
    avatar_url text,
    total_houses_serviced integer DEFAULT 0,
    total_routes_completed integer DEFAULT 0,
    total_hours_driven numeric(10,2) DEFAULT 0,
    average_efficiency numeric(5,2) DEFAULT 0,
    houses_per_hour numeric(5,2) DEFAULT 0,
    last_active_at timestamptz,
    last_route_id uuid,
    team_id uuid REFERENCES public.teams(id) ON DELETE SET NULL
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Now that profiles exists, create the team member policy
CREATE POLICY "Team members can view their team" ON teams
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.team_id = teams.id
            AND profiles.id = auth.uid()
        )
    );

-- Profile policies
DROP POLICY IF EXISTS "Users can view profiles in their team" ON profiles;
DROP POLICY IF EXISTS "Users can manage their own profile" ON profiles;
DROP POLICY IF EXISTS "Team admins can manage team profiles" ON profiles;
DROP POLICY IF EXISTS "Team members can view their team" ON teams;

-- Team policies that don't depend on profiles
CREATE POLICY "Team owners can manage their teams" ON teams
    FOR ALL USING (owner_id = auth.uid());

CREATE POLICY "Anyone can view teams" ON teams
    FOR SELECT USING (true);

-- Profile policies that use teams as source of truth
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can view team member profiles" ON profiles
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM teams
            WHERE id = profiles.team_id
            AND (owner_id = auth.uid() OR id IN (
                SELECT team_id FROM profiles WHERE id = auth.uid()
            ))
        )
    );

CREATE POLICY "Users can manage their own profile" ON profiles
    FOR ALL USING (auth.uid() = id);

CREATE POLICY "Team owners can manage team profiles" ON profiles
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM teams
            WHERE id = profiles.team_id
            AND owner_id = auth.uid()
        )
    );

-- ROUTES TABLE
DROP TABLE IF EXISTS public.routes CASCADE;
CREATE TABLE public.routes (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    name text NOT NULL,
    date timestamptz NOT NULL,
    status route_status NOT NULL DEFAULT 'pending',
    driver_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    total_houses integer NOT NULL CHECK (total_houses > 0),
    completed_houses integer DEFAULT 0,
    duration_minutes integer DEFAULT 0,
    start_time timestamptz,
    end_time timestamptz,
    efficiency numeric(5,2) DEFAULT 0,
    completion_rate numeric(5,2) DEFAULT 0,
    houses_per_hour numeric(5,2) DEFAULT 0,
    special_houses integer DEFAULT 0,
    notes text,
    start_location point,
    end_location point,
    total_distance numeric(10,2) DEFAULT 0
);
ALTER TABLE public.routes ENABLE ROW LEVEL SECURITY;

-- Route policies
DROP POLICY IF EXISTS "Drivers can view their assigned routes" ON routes;
DROP POLICY IF EXISTS "Drivers can manage their routes" ON routes;
DROP POLICY IF EXISTS "Enable read access for all users" ON routes;
DROP POLICY IF EXISTS "Enable insert for drivers and admins" ON routes;
DROP POLICY IF EXISTS "Enable update for assigned drivers and admins" ON routes;
DROP POLICY IF EXISTS "Enable delete for assigned drivers and admins" ON routes;

CREATE POLICY "Users can view their assigned routes" ON routes
    FOR SELECT USING (
        driver_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM teams t
            JOIN profiles p ON p.team_id = t.id
            WHERE p.id = routes.driver_id
            AND (t.owner_id = auth.uid() OR auth.uid() = routes.driver_id)
        )
    );

CREATE POLICY "Users can manage their routes" ON routes
    FOR ALL USING (
        driver_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM teams t
            JOIN profiles p ON p.team_id = t.id
            WHERE p.id = routes.driver_id
            AND t.owner_id = auth.uid()
        )
    );

CREATE POLICY "Enable read access for all users" ON routes
    FOR SELECT USING (true);

CREATE POLICY "Enable insert for drivers and admins" ON routes
    FOR INSERT WITH CHECK (
        auth.uid() = driver_id OR
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Enable update for assigned drivers and admins" ON routes
    FOR UPDATE USING (
        driver_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Enable delete for assigned drivers and admins" ON routes
    FOR DELETE USING (
        driver_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

-- HOUSES TABLE
DROP TABLE IF EXISTS public.houses CASCADE;
CREATE TABLE public.houses (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    route_id uuid REFERENCES public.routes(id) ON DELETE CASCADE NOT NULL,
    address text NOT NULL,
    lat numeric(10,8) NOT NULL CHECK (lat >= -90 AND lat <= 90),
    lng numeric(11,8) NOT NULL CHECK (lng >= -180 AND lng <= 180),
    status house_status NOT NULL DEFAULT 'pending',
    original_status house_status,
    notes text,
    is_new_customer boolean DEFAULT false,
    estimated_time numeric(5,2) DEFAULT 5.00,
    priority integer DEFAULT 0,
    completed_at timestamptz,
    completion_order integer,
    distance_from_prev numeric(10,2)
);
ALTER TABLE public.houses ENABLE ROW LEVEL SECURITY;

-- House policies
DROP POLICY IF EXISTS "Users can view houses in their team routes" ON houses;
DROP POLICY IF EXISTS "Users can manage houses in their routes" ON houses;
DROP POLICY IF EXISTS "Enable read access for all users" ON houses;
DROP POLICY IF EXISTS "Enable insert for route owners and admins" ON houses;
DROP POLICY IF EXISTS "Enable update for route owners and admins" ON houses;
DROP POLICY IF EXISTS "Enable delete for route owners and admins" ON houses;

CREATE POLICY "Users can view houses in their routes" ON houses
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM routes r
            JOIN profiles p ON r.driver_id = p.id
            JOIN teams t ON p.team_id = t.id
            WHERE r.id = houses.route_id
            AND (t.owner_id = auth.uid() OR r.driver_id = auth.uid())
        )
    );

CREATE POLICY "Users can manage houses in their routes" ON houses
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM routes r
            JOIN profiles p ON r.driver_id = p.id
            JOIN teams t ON p.team_id = t.id
            WHERE r.id = houses.route_id
            AND (t.owner_id = auth.uid() OR r.driver_id = auth.uid())
        )
    );

CREATE POLICY "Enable read access for all users" ON houses
    FOR SELECT USING (true);

CREATE POLICY "Enable insert for route owners and admins" ON houses
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM routes r
            WHERE r.id = route_id AND (
                r.driver_id = auth.uid() OR
                EXISTS (
                    SELECT 1 FROM profiles
                    WHERE id = auth.uid() AND role = 'admin'
                )
            )
        )
    );

CREATE POLICY "Enable update for route owners and admins" ON houses
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM routes r
            WHERE r.id = route_id AND (
                r.driver_id = auth.uid() OR
                EXISTS (
                    SELECT 1 FROM profiles
                    WHERE id = auth.uid() AND role = 'admin'
                )
            )
        )
    );

CREATE POLICY "Enable delete for route owners and admins" ON houses
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM routes r
            WHERE r.id = route_id AND (
                r.driver_id = auth.uid() OR
                EXISTS (
                    SELECT 1 FROM profiles
                    WHERE id = auth.uid() AND role = 'admin'
                )
            )
        )
    );

-- GEOCODED_ADDRESSES TABLE
DROP TABLE IF EXISTS public.geocoded_addresses CASCADE;
CREATE TABLE public.geocoded_addresses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    address text NOT NULL UNIQUE,
    lat numeric NOT NULL,
    lng numeric NOT NULL,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL,
    last_used_at timestamptz,
    use_count integer DEFAULT 1
);

-- Function to update profile metrics when a route is completed
CREATE OR REPLACE FUNCTION update_profile_metrics()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
        UPDATE profiles
        SET 
            total_houses_serviced = total_houses_serviced + NEW.completed_houses,
            total_routes_completed = total_routes_completed + 1,
            total_hours_driven = total_hours_driven + (NEW.duration_minutes / 60.0),
            average_efficiency = (
                (average_efficiency * total_routes_completed + NEW.efficiency) / 
                (total_routes_completed + 1)
            ),
            houses_per_hour = (
                (houses_per_hour * total_routes_completed + NEW.houses_per_hour) / 
                (total_routes_completed + 1)
            ),
            updated_at = now()
        WHERE id = NEW.driver_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_route_completed
    AFTER UPDATE ON routes
    FOR EACH ROW
    EXECUTE FUNCTION update_profile_metrics();

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_team_id uuid;
    v_role user_role;
BEGIN
    -- Determine the role
    v_role := COALESCE((NEW.raw_user_meta_data->>'role')::user_role, 'driver'::user_role);
    
    -- If user is an admin, create a new team
    IF v_role = 'admin' THEN
        INSERT INTO teams (name, owner_id)
        VALUES (
            COALESCE(NEW.raw_user_meta_data->>'team_name', 'New Team'),
            NEW.id
        )
        RETURNING id INTO v_team_id;
    END IF;

    -- Create the profile
    INSERT INTO public.profiles (
        id,
        full_name,
        email,
        role,
        status,
        team_id
    ) VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
        NEW.email,
        v_role,
        'active',
        v_team_id
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- Function to calculate route efficiency
CREATE OR REPLACE FUNCTION calculate_route_efficiency(
    p_completed_houses integer,
    p_total_houses integer,
    p_duration_minutes integer
)
RETURNS numeric
LANGUAGE plpgsql
AS $$
DECLARE
    completion_rate numeric;
    houses_per_hour numeric;
    speed_efficiency numeric;
BEGIN
    -- Calculate completion rate (60% weight)
    completion_rate := COALESCE(p_completed_houses::numeric / NULLIF(p_total_houses, 0), 0);
    
    -- Calculate houses per hour and speed efficiency (40% weight)
    houses_per_hour := CASE 
        WHEN p_duration_minutes > 0 THEN
            (p_completed_houses::numeric / (p_duration_minutes::numeric / 60))
        ELSE 0
    END;

    -- Cap speed efficiency at 100% (60 houses/hour is considered 100%)
    speed_efficiency := LEAST(houses_per_hour / 60, 1);
    
    -- Return weighted average
    RETURN ROUND((0.6 * completion_rate + 0.4 * speed_efficiency) * 100, 2);
END;
$$;

-- Create indexes for performance
CREATE INDEX idx_routes_driver_date ON routes(driver_id, date);
CREATE INDEX idx_routes_status ON routes(status);
CREATE INDEX idx_houses_route ON houses(route_id);
CREATE INDEX idx_houses_status ON houses(status);
CREATE INDEX idx_geocoded_addresses_coords ON geocoded_addresses(lat, lng);

-- Enable real-time subscriptions
DROP PUBLICATION IF EXISTS supabase_realtime;
CREATE PUBLICATION supabase_realtime FOR TABLE 
    profiles,
    routes,
    houses;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;
