-- Drop existing objects
DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;

-- Initial permissions
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres, anon, authenticated, service_role;

GRANT USAGE ON SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO postgres, anon, authenticated, service_role;

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Set timezone
ALTER DATABASE postgres SET timezone TO 'UTC';

-- Create custom types for status enums
CREATE TYPE public.route_status AS ENUM ('pending', 'in_progress', 'completed', 'expired');
CREATE TYPE public.house_status AS ENUM ('pending', 'collect', 'skip', 'new customer');
CREATE TYPE public.user_role AS ENUM ('driver', 'admin');
CREATE TYPE public.user_status AS ENUM ('pending', 'active', 'inactive');

-- Create tables
CREATE TABLE public.profiles (
    id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    full_name text NOT NULL,
    email text NOT NULL UNIQUE,
    role user_role NOT NULL DEFAULT 'driver',
    status user_status NOT NULL DEFAULT 'active',
    phone text,
    preferred_region text,
    start_date date DEFAULT now(),
    avatar_url text,
    hours_driven numeric(10,2) DEFAULT 0,
    total_houses_serviced integer DEFAULT 0,
    total_routes_completed integer DEFAULT 0,
    average_efficiency numeric(5,2) DEFAULT 0
);

CREATE TABLE public.routes (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    name text NOT NULL,
    date timestamptz NOT NULL,
    status route_status NOT NULL DEFAULT 'pending',
    duration numeric(5,2) DEFAULT 0,
    completed_houses integer DEFAULT 0,
    total_houses integer NOT NULL CHECK (total_houses > 0),
    efficiency numeric(5,2) DEFAULT 0 CHECK (efficiency >= 0 AND efficiency <= 100),
    completion_rate numeric(5,2) DEFAULT 0,
    houses_per_hour numeric(5,2) DEFAULT 0,
    special_houses integer DEFAULT 0,
    driver_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    start_time timestamptz,
    end_time timestamptz,
    notes text
);

CREATE TABLE public.houses (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    address text NOT NULL,
    lat numeric(10,8) NOT NULL CHECK (lat >= -90 AND lat <= 90),
    lng numeric(11,8) NOT NULL CHECK (lng >= -180 AND lng <= 180),
    status house_status NOT NULL DEFAULT 'pending',
    original_status house_status,
    notes text,
    route_id uuid REFERENCES public.routes(id) ON DELETE CASCADE NOT NULL,
    is_new_customer boolean DEFAULT false,
    estimated_time numeric(5,2) DEFAULT 5.00,
    priority integer DEFAULT 0
);

-- Create geocoding cache table
CREATE TABLE public.geocoded_addresses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    address text NOT NULL UNIQUE,
    lat numeric NOT NULL,
    lng numeric NOT NULL,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create indexes
CREATE INDEX routes_date_idx ON public.routes(date);
CREATE INDEX routes_status_idx ON public.routes(status);
CREATE INDEX routes_driver_id_idx ON public.routes(driver_id);
CREATE INDEX houses_route_id_idx ON public.houses(route_id);
CREATE INDEX houses_status_idx ON public.houses(status);
CREATE INDEX idx_geocoded_addresses_address ON geocoded_addresses(address);

-- Create function to handle updated_at timestamps
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create function to handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
    existing_user_count INTEGER;
    max_retries INTEGER := 3;
    current_retry INTEGER := 0;
    profile_created BOOLEAN := FALSE;
BEGIN
    -- Keep trying until success or max retries reached
    WHILE NOT profile_created AND current_retry < max_retries LOOP
        BEGIN
            -- Increment retry counter
            current_retry := current_retry + 1;
            
            -- Wait longer on each retry
            PERFORM pg_sleep(0.5 * current_retry);
            
            -- Check if profile already exists
            IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN
                RAISE NOTICE 'Profile already exists for user %', NEW.id;
                profile_created := TRUE;
                RETURN NEW;
            END IF;
            
            -- Check if this is the first user
            SELECT COUNT(*) INTO existing_user_count FROM public.profiles;
            
            -- Create profile
            INSERT INTO public.profiles (
                id,
                full_name,
                email,
                role,
                status,
                created_at,
                updated_at
            ) VALUES (
                NEW.id,
                COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
                NEW.email,
                CASE 
                    WHEN existing_user_count = 0 THEN 'admin'::user_role
                    ELSE COALESCE((NEW.raw_user_meta_data->>'role')::user_role, 'driver'::user_role)
                END,
                'active'::user_status,
                NOW(),
                NOW()
            );
            
            -- If we got here, profile was created successfully
            profile_created := TRUE;
            
            -- Log success
            RAISE NOTICE 'Profile created successfully for user % on attempt %', NEW.id, current_retry;
            
        EXCEPTION
            WHEN unique_violation THEN
                -- Profile might have been created by another process
                IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN
                    profile_created := TRUE;
                    RAISE NOTICE 'Profile already exists for user % (created by another process)', NEW.id;
                ELSIF current_retry < max_retries THEN
                    RAISE NOTICE 'Attempt % failed for user % due to unique violation. Retrying...', current_retry, NEW.id;
                    CONTINUE;
                ELSE
                    RAISE EXCEPTION 'Failed to create profile after % attempts due to unique violation', max_retries;
                END IF;
            WHEN foreign_key_violation THEN
                -- Only retry if we haven't hit max retries
                IF current_retry < max_retries THEN
                    RAISE NOTICE 'Attempt % failed for user % due to foreign key violation. Retrying...', current_retry, NEW.id;
                    CONTINUE;
                ELSE
                    RAISE EXCEPTION 'Failed to create profile after % attempts due to foreign key violation', max_retries;
                END IF;
            WHEN OTHERS THEN
                -- Log other errors but don't retry
                RAISE NOTICE 'Error creating profile for user % on attempt %: %', NEW.id, current_retry, SQLERRM;
                RAISE;
        END;
    END LOOP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to calculate route metrics
CREATE OR REPLACE FUNCTION calculate_route_metrics()
RETURNS TRIGGER AS $$
BEGIN
    -- Calculate basic metrics
    NEW.completed_houses = (
        SELECT COUNT(*) FROM houses 
        WHERE route_id = NEW.id AND status = 'collect'
    );
    
    -- Calculate special houses
    NEW.special_houses = (
        SELECT COUNT(*) FROM houses 
        WHERE route_id = NEW.id AND (status = 'skip' OR status = 'new customer')
    );
    
    -- Calculate duration if route is completed
    IF NEW.end_time IS NOT NULL AND NEW.start_time IS NOT NULL THEN
        NEW.duration = EXTRACT(EPOCH FROM (NEW.end_time - NEW.start_time))/3600;
    END IF;
    
    -- Calculate houses per hour
    IF NEW.duration > 0 THEN
        NEW.houses_per_hour = NEW.completed_houses::numeric / NEW.duration;
    END IF;
    
    -- Calculate completion rate
    IF NEW.total_houses > 0 THEN
        NEW.completion_rate = (NEW.completed_houses::numeric / NEW.total_houses::numeric) * 100;
    END IF;
    
    -- Calculate efficiency (60% completion, 40% speed)
    IF NEW.duration > 0 AND NEW.total_houses > 0 THEN
        NEW.efficiency = (
            (NEW.completion_rate * 0.6) + 
            ((NEW.houses_per_hour / (NEW.total_houses::numeric / 8)) * 40)
        );
    END IF;

    -- Auto-expire routes
    IF NEW.status = 'pending' AND NEW.date < CURRENT_DATE THEN
        NEW.status = 'expired';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create function to update profile metrics
CREATE OR REPLACE FUNCTION update_profile_metrics()
RETURNS TRIGGER AS $$
BEGIN
    -- Update profile metrics when a route is completed
    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
        UPDATE public.profiles
        SET 
            hours_driven = hours_driven + COALESCE(NEW.duration, 0),
            total_houses_serviced = total_houses_serviced + COALESCE(NEW.completed_houses, 0),
            total_routes_completed = total_routes_completed + 1,
            average_efficiency = (
                SELECT AVG(efficiency)
                FROM public.routes
                WHERE driver_id = NEW.driver_id
                AND status = 'completed'
            )
        WHERE id = NEW.driver_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER handle_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER handle_routes_updated_at
    BEFORE UPDATE ON public.routes
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER handle_houses_updated_at
    BEFORE UPDATE ON public.houses
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER update_route_metrics
    BEFORE INSERT OR UPDATE ON public.routes
    FOR EACH ROW
    EXECUTE FUNCTION calculate_route_metrics();

CREATE TRIGGER update_profile_metrics
    AFTER UPDATE ON public.routes
    FOR EACH ROW
    EXECUTE FUNCTION update_profile_metrics();

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.routes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.houses ENABLE ROW LEVEL SECURITY;

-- Drop existing policies
DROP POLICY IF EXISTS "Enable insert for service role" ON public.profiles;
DROP POLICY IF EXISTS "Enable select for authenticated users" ON public.profiles;
DROP POLICY IF EXISTS "Enable update for users based on id" ON public.profiles;

-- Create new policies without circular dependencies
CREATE POLICY "Enable insert for authenticated users" ON public.profiles
    FOR INSERT
    WITH CHECK (auth.uid() = id);

CREATE POLICY "Enable select for users and admins" ON public.profiles
    FOR SELECT
    USING (
        -- Users can see their own profile
        auth.uid() = id
        -- Admins can see all profiles
        OR EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Enable update for users and admins" ON public.profiles
    FOR UPDATE
    USING (
        -- Users can update their own profile
        auth.uid() = id
        -- Admins can update any profile
        OR EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

-- Routes viewable by admin or assigned driver
CREATE POLICY "Routes viewable by admin or assigned driver" ON public.routes
    FOR SELECT
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR driver_id = auth.uid()
    );

CREATE POLICY "Routes insertable by admin" ON public.routes
    FOR INSERT
    WITH CHECK (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
    );

CREATE POLICY "Routes updatable by admin or assigned driver" ON public.routes
    FOR UPDATE
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR driver_id = auth.uid()
    );

CREATE POLICY "Routes deletable by admin" ON public.routes
    FOR DELETE
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
    );

-- Houses viewable by admin or route driver
CREATE POLICY "Houses viewable by admin or route driver" ON public.houses
    FOR SELECT
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR EXISTS (
            SELECT 1 FROM routes 
            WHERE routes.id = route_id 
            AND routes.driver_id = auth.uid()
        )
    );

CREATE POLICY "Houses insertable by admin" ON public.houses
    FOR INSERT
    WITH CHECK (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
    );

CREATE POLICY "Houses updatable by admin or route driver" ON public.houses
    FOR UPDATE
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR EXISTS (
            SELECT 1 FROM routes 
            WHERE routes.id = route_id 
            AND routes.driver_id = auth.uid()
        )
    );

CREATE POLICY "Houses deletable by admin" ON public.houses
    FOR DELETE
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
    );

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO service_role;

-- Final permissions (in case any objects were created after initial grants)
GRANT USAGE ON SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO postgres, anon, authenticated, service_role;

-- Handle future tables
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO authenticated, anon, service_role;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated, anon, service_role;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated, anon, service_role;

-- Ensure public schema is accessible
GRANT USAGE ON SCHEMA public TO PUBLIC;

-- Enable access to auth schema for profile creation
GRANT USAGE ON SCHEMA auth TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO service_role;

-- Grant specific permissions for auth.users
GRANT SELECT, INSERT, UPDATE, DELETE ON auth.users TO service_role;
GRANT SELECT ON auth.users TO authenticated;

-- Ensure RLS is enabled but allow service role access
ALTER TABLE auth.users FORCE ROW LEVEL SECURITY;

-- Create policy for service role to access auth.users
CREATE POLICY service_role_access_policy ON auth.users 
    FOR ALL 
    TO service_role 
    USING (true)
    WITH CHECK (true);

-- Ensure RLS is enabled
ALTER TABLE public.profiles FORCE ROW LEVEL SECURITY;
ALTER TABLE public.routes FORCE ROW LEVEL SECURITY;
ALTER TABLE public.houses FORCE ROW LEVEL SECURITY; 