-- Drop existing objects
DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Set timezone
ALTER DATABASE postgres SET timezone TO 'UTC';

-- Create custom types for status enums
CREATE TYPE public.route_status AS ENUM ('pending', 'in_progress', 'completed', 'expired');
CREATE TYPE public.house_status AS ENUM ('pending', 'collect', 'skip', 'new customer');
CREATE TYPE public.user_role AS ENUM ('driver', 'admin');
CREATE TYPE public.user_status AS ENUM ('pending', 'active', 'inactive');

-- Create tables
CREATE TABLE public.profiles (
    id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    full_name text NOT NULL,
    email text NOT NULL UNIQUE,
    role user_role NOT NULL DEFAULT 'driver',
    status user_status NOT NULL DEFAULT 'active',
    phone text,
    preferred_region text,
    start_date date DEFAULT now(),
    avatar_url text,
    hours_driven numeric(10,2) DEFAULT 0,
    total_houses_serviced integer DEFAULT 0,
    total_routes_completed integer DEFAULT 0,
    average_efficiency numeric(5,2) DEFAULT 0
);

CREATE TABLE public.routes (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    name text NOT NULL,
    date timestamptz NOT NULL,
    status route_status NOT NULL DEFAULT 'pending',
    duration numeric(5,2) DEFAULT 0,
    completed_houses integer DEFAULT 0,
    total_houses integer NOT NULL CHECK (total_houses > 0),
    efficiency numeric(5,2) DEFAULT 0 CHECK (efficiency >= 0 AND efficiency <= 100),
    completion_rate numeric(5,2) DEFAULT 0,
    houses_per_hour numeric(5,2) DEFAULT 0,
    special_houses integer DEFAULT 0,
    driver_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    start_time timestamptz,
    end_time timestamptz,
    notes text
);

CREATE TABLE public.houses (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    address text NOT NULL,
    lat numeric(10,8) NOT NULL CHECK (lat >= -90 AND lat <= 90),
    lng numeric(11,8) NOT NULL CHECK (lng >= -180 AND lng <= 180),
    status house_status NOT NULL DEFAULT 'pending',
    original_status house_status,
    notes text,
    route_id uuid REFERENCES public.routes(id) ON DELETE CASCADE NOT NULL,
    is_new_customer boolean DEFAULT false,
    estimated_time numeric(5,2) DEFAULT 5.00,
    priority integer DEFAULT 0
);

-- Create geocoding cache table
CREATE TABLE public.geocoded_addresses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    address text NOT NULL UNIQUE,
    lat numeric NOT NULL,
    lng numeric NOT NULL,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create indexes
CREATE INDEX routes_date_idx ON public.routes(date);
CREATE INDEX routes_status_idx ON public.routes(status);
CREATE INDEX routes_driver_id_idx ON public.routes(driver_id);
CREATE INDEX houses_route_id_idx ON public.houses(route_id);
CREATE INDEX houses_status_idx ON public.houses(status);
CREATE INDEX idx_geocoded_addresses_address ON geocoded_addresses(address);

-- Create function to handle updated_at timestamps
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create function to handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
    existing_user_count INTEGER;
BEGIN
    -- Wait a short moment to ensure the auth.users record is committed
    PERFORM pg_sleep(0.1);
    
    -- Check if this is the first user
    SELECT COUNT(*) INTO existing_user_count FROM public.profiles;
    
    -- Create profile
    INSERT INTO public.profiles (
        id,
        full_name,
        email,
        role,
        status
    ) VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
        NEW.email,
        CASE 
            WHEN existing_user_count = 0 THEN 'admin'::user_role
            ELSE COALESCE((NEW.raw_user_meta_data->>'role')::user_role, 'driver'::user_role)
        END,
        'active'::user_status
    );
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- Log error details
        RAISE NOTICE 'Error creating profile for user %: %', NEW.id, SQLERRM;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to calculate route metrics
CREATE OR REPLACE FUNCTION calculate_route_metrics()
RETURNS TRIGGER AS $$
BEGIN
    -- Calculate basic metrics
    NEW.completed_houses = (
        SELECT COUNT(*) FROM houses 
        WHERE route_id = NEW.id AND status = 'collect'
    );
    
    -- Calculate special houses
    NEW.special_houses = (
        SELECT COUNT(*) FROM houses 
        WHERE route_id = NEW.id AND (status = 'skip' OR status = 'new customer')
    );
    
    -- Calculate duration if route is completed
    IF NEW.end_time IS NOT NULL AND NEW.start_time IS NOT NULL THEN
        NEW.duration = EXTRACT(EPOCH FROM (NEW.end_time - NEW.start_time))/3600;
    END IF;
    
    -- Calculate houses per hour
    IF NEW.duration > 0 THEN
        NEW.houses_per_hour = NEW.completed_houses::numeric / NEW.duration;
    END IF;
    
    -- Calculate completion rate
    IF NEW.total_houses > 0 THEN
        NEW.completion_rate = (NEW.completed_houses::numeric / NEW.total_houses::numeric) * 100;
    END IF;
    
    -- Calculate efficiency (60% completion, 40% speed)
    IF NEW.duration > 0 AND NEW.total_houses > 0 THEN
        NEW.efficiency = (
            (NEW.completion_rate * 0.6) + 
            ((NEW.houses_per_hour / (NEW.total_houses::numeric / 8)) * 40)
        );
    END IF;

    -- Auto-expire routes
    IF NEW.status = 'pending' AND NEW.date < CURRENT_DATE THEN
        NEW.status = 'expired';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create function to update profile metrics
CREATE OR REPLACE FUNCTION update_profile_metrics()
RETURNS TRIGGER AS $$
BEGIN
    -- Update profile metrics when a route is completed
    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
        UPDATE public.profiles
        SET 
            hours_driven = hours_driven + COALESCE(NEW.duration, 0),
            total_houses_serviced = total_houses_serviced + COALESCE(NEW.completed_houses, 0),
            total_routes_completed = total_routes_completed + 1,
            average_efficiency = (
                SELECT AVG(efficiency)
                FROM public.routes
                WHERE driver_id = NEW.driver_id
                AND status = 'completed'
            )
        WHERE id = NEW.driver_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER handle_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER handle_routes_updated_at
    BEFORE UPDATE ON public.routes
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER handle_houses_updated_at
    BEFORE UPDATE ON public.houses
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER update_route_metrics
    BEFORE INSERT OR UPDATE ON public.routes
    FOR EACH ROW
    EXECUTE FUNCTION calculate_route_metrics();

CREATE TRIGGER update_profile_metrics
    AFTER UPDATE ON public.routes
    FOR EACH ROW
    EXECUTE FUNCTION update_profile_metrics();

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.routes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.houses ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Enable insert for service role" ON public.profiles
  FOR INSERT
    WITH CHECK (true);

CREATE POLICY "Enable select for authenticated users" ON public.profiles
  FOR SELECT
  USING (auth.role() = 'authenticated');

CREATE POLICY "Enable update for users based on id" ON public.profiles
  FOR UPDATE
    USING (
        auth.uid() = id OR 
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Routes viewable by admin or assigned driver" ON public.routes
    FOR SELECT
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR driver_id = auth.uid()
    );

CREATE POLICY "Routes insertable by admin" ON public.routes
    FOR INSERT
    WITH CHECK (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
    );

CREATE POLICY "Routes updatable by admin or assigned driver" ON public.routes
    FOR UPDATE
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR driver_id = auth.uid()
    );

CREATE POLICY "Routes deletable by admin" ON public.routes
    FOR DELETE
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
    );

CREATE POLICY "Houses viewable by admin or route driver" ON public.houses
    FOR SELECT
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR EXISTS (
            SELECT 1 FROM routes 
            WHERE routes.id = route_id 
            AND routes.driver_id = auth.uid()
        )
    );

CREATE POLICY "Houses insertable by admin or route driver" ON public.houses
    FOR INSERT
    WITH CHECK (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR EXISTS (
            SELECT 1 FROM routes 
            WHERE routes.id = route_id 
            AND routes.driver_id = auth.uid()
        )
    );

CREATE POLICY "Houses updatable by admin or route driver" ON public.houses
    FOR UPDATE
    USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
        OR EXISTS (
            SELECT 1 FROM routes 
            WHERE routes.id = route_id 
            AND routes.driver_id = auth.uid()
        )
    );

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role; 