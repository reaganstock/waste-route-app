-- Start fresh
DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;

-- Initial setup
ALTER DATABASE postgres SET timezone TO 'UTC';
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Grant initial permissions
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres, anon, authenticated, service_role;

-- Create ENUMs
CREATE TYPE public.route_status AS ENUM ('pending', 'in_progress', 'completed', 'expired');
CREATE TYPE public.house_status AS ENUM ('pending', 'collect', 'skip', 'new customer');
CREATE TYPE public.user_role AS ENUM ('driver', 'admin');
CREATE TYPE public.user_status AS ENUM ('pending', 'active', 'inactive');

-- Create tables
CREATE TABLE public.profiles (
    id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    full_name text NOT NULL,
    email text NOT NULL UNIQUE,
    role user_role NOT NULL DEFAULT 'driver',
    status user_status NOT NULL DEFAULT 'active',
    phone text,
    preferred_region text,
    start_date date DEFAULT now(),
    avatar_url text,
    hours_driven numeric(10,2) DEFAULT 0,
    total_houses_serviced integer DEFAULT 0,
    total_routes_completed integer DEFAULT 0,
    average_efficiency numeric(5,2) DEFAULT 0
);

CREATE TABLE public.routes (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    name text NOT NULL,
    date timestamptz NOT NULL,
    status route_status NOT NULL DEFAULT 'pending',
    duration numeric(5,2) DEFAULT 0,
    completed_houses integer DEFAULT 0,
    total_houses integer NOT NULL CHECK (total_houses > 0),
    efficiency numeric(5,2) DEFAULT 0 CHECK (efficiency >= 0 AND efficiency <= 100),
    completion_rate numeric(5,2) DEFAULT 0,
    houses_per_hour numeric(5,2) DEFAULT 0,
    special_houses integer DEFAULT 0,
    driver_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    start_time timestamptz,
    end_time timestamptz,
    notes text
);

CREATE TABLE public.houses (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    address text NOT NULL,
    lat numeric(10,8) NOT NULL CHECK (lat >= -90 AND lat <= 90),
    lng numeric(11,8) NOT NULL CHECK (lng >= -180 AND lng <= 180),
    status house_status NOT NULL DEFAULT 'pending',
    original_status house_status,
    notes text,
    route_id uuid REFERENCES public.routes(id) ON DELETE CASCADE NOT NULL,
    is_new_customer boolean DEFAULT false,
    estimated_time numeric(5,2) DEFAULT 5.00,
    priority integer DEFAULT 0
);

CREATE TABLE public.geocoded_addresses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    address text NOT NULL UNIQUE,
    lat numeric NOT NULL,
    lng numeric NOT NULL,
    created_at timestamptz DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create indexes
CREATE INDEX routes_date_idx ON public.routes(date);
CREATE INDEX routes_status_idx ON public.routes(status);
CREATE INDEX routes_driver_id_idx ON public.routes(driver_id);
CREATE INDEX houses_route_id_idx ON public.houses(route_id);
CREATE INDEX houses_status_idx ON public.houses(status);
CREATE INDEX idx_geocoded_addresses_address ON geocoded_addresses(address);

-- Function to handle updated_at timestamps
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to handle new user signup with retries
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
    max_retries INTEGER := 3;
    current_retry INTEGER := 0;
    profile_created BOOLEAN := FALSE;
BEGIN
    -- Keep trying until success or max retries reached
    WHILE NOT profile_created AND current_retry < max_retries LOOP
        BEGIN
            current_retry := current_retry + 1;
            
            -- Wait longer on each retry
            PERFORM pg_sleep(0.5 * current_retry);
            
            -- Check if profile already exists
            IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN
                profile_created := TRUE;
                RETURN NEW;
            END IF;

            -- Create profile
            INSERT INTO public.profiles (
                id,
                full_name,
                email,
                role,
                status,
                created_at,
                updated_at
            ) VALUES (
                NEW.id,
                COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
                NEW.email,
                COALESCE((NEW.raw_user_meta_data->>'role')::user_role, 'driver'::user_role),
                'active'::user_status,
                NOW(),
                NOW()
            );
            
            profile_created := TRUE;
            
        EXCEPTION
            WHEN unique_violation THEN
                IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN
                    profile_created := TRUE;
                ELSIF current_retry < max_retries THEN
                    CONTINUE;
                ELSE
                    RAISE EXCEPTION 'Failed to create profile after % attempts', max_retries;
                END IF;
            WHEN foreign_key_violation THEN
                IF current_retry < max_retries THEN
                    CONTINUE;
                ELSE
                    RAISE EXCEPTION 'Failed to create profile after % attempts', max_retries;
                END IF;
        END;
    END LOOP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create triggers
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER handle_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER handle_routes_updated_at
    BEFORE UPDATE ON public.routes
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER handle_houses_updated_at
    BEFORE UPDATE ON public.houses
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.routes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.houses ENABLE ROW LEVEL SECURITY;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT USAGE ON SCHEMA public TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role;

-- Grant auth schema access
GRANT USAGE ON SCHEMA auth TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO service_role;

-- Create RLS policies
CREATE POLICY "Users can view own profile"
    ON public.profiles FOR SELECT
    USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
    ON public.profiles FOR UPDATE
    USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles"
    ON public.profiles FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Admins can update all profiles"
    ON public.profiles FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Service role can create profiles"
    ON public.profiles FOR INSERT
    WITH CHECK (auth.jwt() ->> 'role' = 'service_role');

-- Route policies
CREATE POLICY "Users can view assigned routes"
    ON public.routes FOR SELECT
    USING (driver_id = auth.uid());

CREATE POLICY "Admins can view all routes"
    ON public.routes FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Users can update assigned routes"
    ON public.routes FOR UPDATE
    USING (driver_id = auth.uid());

CREATE POLICY "Admins can update all routes"
    ON public.routes FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Admins can create routes"
    ON public.routes FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Admins can delete routes"
    ON public.routes FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

-- House policies
CREATE POLICY "Users can view houses on assigned routes"
    ON public.houses FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM routes
            WHERE routes.id = route_id
            AND routes.driver_id = auth.uid()
        )
    );

CREATE POLICY "Admins can view all houses"
    ON public.houses FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Users can update houses on assigned routes"
    ON public.houses FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM routes
            WHERE routes.id = route_id
            AND routes.driver_id = auth.uid()
        )
    );

CREATE POLICY "Admins can update all houses"
    ON public.houses FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Admins can create houses"
    ON public.houses FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

CREATE POLICY "Admins can delete houses"
    ON public.houses FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM auth.users
            WHERE auth.users.id = auth.uid()
            AND (auth.users.raw_user_meta_data->>'role')::text = 'admin'
        )
    );

-- Include the metric calculation functions from the previous migration
